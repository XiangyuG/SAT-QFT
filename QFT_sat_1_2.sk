harness void main() {
    // initialization of their position
    int n = 2;
    int N = 1;
    
    int[2] arr = {0,1};
    int[2] pos = {0,1};
    
    int[2][2] I = {{0, 0}, {0, 0}};
    int C000= ??(1);
    int C001= ??(1);
    int C002= ??(1);
    int C003= ??(1);
    int C010= ??(1);
    int C011= ??(1);
    int C012= ??(1);
    int C013= ??(1);
    int C00_SC = ??(1);
    int C01_SC = ??(1);
    int[5][2][1] gate_swap = {{{C000, C001, C002, C003,C00_SC},{C010, C011, C012, C013,C01_SC}}};
    // Ensure that at most one should be 1
    assert (C000+C001+C002+C003<=1);
    assert (C010+C011+C012+C013<=1);

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < n; j++) {
            if (gate_swap[i][j][0] == 1) {
                // L CX
                assert (pos[j] > 0);
                int v = arr[pos[j] - 1];
                // dependency constraints (all I[p][q] where )
                assert (v > j);
                assert (I[j][v] == 0);
                assert (gate_swap[i][v][4] == j);
                assert (gate_swap[i][v][0]+gate_swap[i][v][1]+gate_swap[i][v][2]+gate_swap[i][v][3] == 0);
                for (int p = 0; p < j; p++) {
                    assert (I[p][j] == 1);  // j is OK to do CX
                    assert (I[p][v] == 1);  // v is CXed by other nodes smaller than j
                }
                I[j][v] = 1;
                
            } else if (gate_swap[i][j][1] == 1) {
                // R CX
                assert (pos[j] < n - 1);
                int v = arr[pos[j] + 1];
                // dependency constraints
                assert (gate_swap[i][v][0]+gate_swap[i][v][1]+gate_swap[i][v][2]+gate_swap[i][v][3] == 0);
                assert (v > j);
                assert (I[j][v] == 0);
                assert (gate_swap[i][v][4] == j);
                for (int p = 0; p < j; p++) {
                    assert (I[p][j] == 1);  // j is OK to do CX
                    assert (I[p][v] == 1);  // v is CXed by other nodes smaller than j
                }
                I[j][v] = 1;
                
            } else if (gate_swap[i][j][2] == 1) {
               // L Swap
               assert (pos[j] > 0);
               int v = arr[pos[j] - 1];
               assert (gate_swap[i][v][3] == 1);
            } else if (gate_swap[i][j][3] == 1) {
               // R Swap
               assert (pos[j] < n - 1);
               int v = arr[pos[j] + 1];
               assert (gate_swap[i][v][2] == 1);
            }
        }
        // Update pos vec
        for (int j = 0; j < n; j++) {
            if (arr[pos[j]] == j) {
                if (gate_swap[i][j][2] == 1) {
                    int v = arr[pos[j] - 1];
                    pos[j] = pos[j] - 1;
                    pos[v] = pos[v] + 1;
                } else if (gate_swap[i][j][3] == 1) {
                    int v = arr[pos[j] + 1];
                    pos[j] = pos[j] + 1;
                    pos[v] = pos[v] - 1;
                }   
            }
        }
        // Update arr 
	    for (int j = 0; j < n; j++) {
            arr[pos[j]] = j;
        }        
    }
    assert (I == {{0,1},{0,0}});
}
